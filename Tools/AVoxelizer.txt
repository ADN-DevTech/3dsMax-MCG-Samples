(InstanceState state, Int32 grid_y, BoundingBox boundingBox, Int32 grid_x, Int32 grid_z, TriMesh mesh, Boolean caching, Single box size) => 
  {
    Int32 _0One;// 10:PlusOne->1:One 89878
    Int32 _1Add;// 10:PlusOne->0:Add 89877
    IArray[Single] _2RangeInclusiveFloat;// 5:SampleLerp->2:RangeInclusiveFloat 89874
    Vector3 _3BoxMin;// 0:SubdivideBoxAlongDiagonal->2:BoxMin 89879
    Vector3 _4BoxMax;// 0:SubdivideBoxAlongDiagonal->3:BoxMax 89880
    Func[Single, Vector3] _5Pass-through: function1;// 0:Pass-through: function1 89872
    IArray[Vector3] _6Map;// 5:SampleLerp->3:Map 89873
    Int32 _7Count;// 3:LastIndex->2:Count 89867
    Int32 _8One;// 3:MinusOne->2:One 89866
    Int32 _9Subtract;// 3:MinusOne->1:Subtract 89865
    IArray[Vector3] _10Take;// 6:DropLast->2:Take 89862
    Int32 _11One;// 5:SkipOne->2:One 89883
    IArray[Vector3] _12Skip;// 5:SkipOne->3:Skip 89882
    IArray[BoundingBox] _13Combine;// 0:SubdivideBoxAlongDiagonal->7:Combine 89860
    IArray[BoundingBox] _14Map;// 4:SubdivideBoxAlongX->1:Map 89857
    Func[BoundingBox, IArray[BoundingBox]] _15Pass-through: function1;// 0:Pass-through: function1 89852
    IArray[IArray[BoundingBox]] _16Map;// 7:FlatMap->4:Map 89854
    IArray[BoundingBox] _17Flatten;// 7:FlatMap->3:Flatten 89853
    Func[BoundingBox, IArray[BoundingBox]] _18Pass-through: function1;// 0:Pass-through: function1 89848
    IArray[IArray[BoundingBox]] _19Map;// 8:FlatMap->4:Map 89850
    IArray[BoundingBox] _20Flatten;// 8:FlatMap->3:Flatten 89849
    Int32 _21Two;// 12:CacheValueWhileTrueWithUpdate-ext->2:Two 90023
    Cache[Tuple[RayTraceScene, Int32]] _22CreateCache;// 12:CacheValueWhileTrueWithUpdate-ext->0:CreateCache 90019
    Int32 _23Zero;// 3:ExtractCurrentValueFromCache->3:Zero 90018
    Tuple[RayTraceScene, Int32] _24CachedValue;// 3:ExtractCurrentValueFromCache->1:CachedValue 90017
    RayTraceScene _25PairItem1;// 0:RayTraceCachedScene-ext->4:PairItem1 90012
    IArray[BoundingBox] _26Filter;// 26:Filter 89842
    Single _27Constant;// 13:PercentToDecimal-ext->0:Constant 90066
    Single _28Divide;// 13:PercentToDecimal-ext->42:Divide 90065
    IArray[TriMesh] _29ParallelMap;// 17:ParallelMap 89841
    TriMesh _30CombineAllMeshes;// 19:CombineAllMeshes 89840
    _0One = One();
    _1Add = Add(grid_y, _0One);
    _2RangeInclusiveFloat = RangeInclusiveFloat(_1Add);
    _3BoxMin = BoxMin(boundingBox);
    _4BoxMax = BoxMax(boundingBox);
    _5Pass-through: function1 = (Single x0) => 
      {
        Vector3 _0Lerp;// 4:ArrayOfLerpedVectors->3:Lerp 89875
        _0Lerp = Lerp(_3BoxMin, _4BoxMax, x0);
        _0Lerp;
        };
    _6Map = Map(_2RangeInclusiveFloat, _5Pass-through: function1);
    _7Count = Count(_6Map);
    _8One = One();
    _9Subtract = Subtract(_7Count, _8One);
    _10Take = Take(_6Map, _9Subtract);
    _11One = One();
    _12Skip = Skip(_6Map, _11One);
    _13Combine = Combine(_10Take, _12Skip, (Vector3 x0, Vector3 x1) => 
      {
        BoundingBox _0Box;// 0:SubdivideBoxAlongDiagonal->8:Box 89884
        _0Box = Box(x0, x1);
        _0Box;
        });
    _14Map = Map(_13Combine, (BoundingBox x0) => 
      {
        Vector3 _0BoxMin;// 2:MatchBoxX->7:BoxMin 89890
        Single _1X;// 2:MatchBoxX->4:X 89889
        Vector3 _2BoxMin;// 2:MatchBoxX->5:BoxMin 89892
        Single _3Y;// 2:MatchBoxX->8:Y 89891
        Single _4Z;// 2:MatchBoxX->0:Z 89893
        Vector3 _5Vector3;// 2:MatchBoxX->10:Vector3 89888
        Vector3 _6BoxMax;// 2:MatchBoxX->9:BoxMax 89896
        Single _7X;// 2:MatchBoxX->13:X 89895
        Vector3 _8BoxMax;// 2:MatchBoxX->15:BoxMax 89898
        Single _9Y;// 2:MatchBoxX->11:Y 89897
        Single _10Z;// 2:MatchBoxX->12:Z 89899
        Vector3 _11Vector3;// 2:MatchBoxX->6:Vector3 89894
        BoundingBox _12Box;// 2:MatchBoxX->14:Box 89887
        _0BoxMin = BoxMin(x0);
        _1X = X(_0BoxMin);
        _2BoxMin = BoxMin(boundingBox);
        _3Y = Y(_2BoxMin);
        _4Z = Z(_2BoxMin);
        _5Vector3 = Vector3(_1X, _3Y, _4Z);
        _6BoxMax = BoxMax(x0);
        _7X = X(_6BoxMax);
        _8BoxMax = BoxMax(boundingBox);
        _9Y = Y(_8BoxMax);
        _10Z = Z(_8BoxMax);
        _11Vector3 = Vector3(_7X, _9Y, _10Z);
        _12Box = Box(_5Vector3, _11Vector3);
        _12Box;
        });
    _15Pass-through: function1 = (BoundingBox x0) => 
      {
        Int32 _0One;// 10:PlusOne->1:One 89923
        Int32 _1Add;// 10:PlusOne->0:Add 89922
        IArray[Single] _2RangeInclusiveFloat;// 5:SampleLerp->2:RangeInclusiveFloat 89919
        Vector3 _3BoxMin;// 2:SubdivideBoxAlongDiagonal->2:BoxMin 89924
        Vector3 _4BoxMax;// 2:SubdivideBoxAlongDiagonal->3:BoxMax 89925
        Func[Single, Vector3] _5Pass-through: function1;// 0:Pass-through: function1 89917
        IArray[Vector3] _6Map;// 5:SampleLerp->3:Map 89918
        Int32 _7Count;// 3:LastIndex->2:Count 89912
        Int32 _8One;// 3:MinusOne->2:One 89911
        Int32 _9Subtract;// 3:MinusOne->1:Subtract 89910
        IArray[Vector3] _10Take;// 6:DropLast->2:Take 89907
        Int32 _11One;// 5:SkipOne->2:One 89928
        IArray[Vector3] _12Skip;// 5:SkipOne->3:Skip 89927
        IArray[BoundingBox] _13Combine;// 2:SubdivideBoxAlongDiagonal->7:Combine 89905
        IArray[BoundingBox] _14Map;// 5:SubdivideBoxAlongY->0:Map 89902
        _0One = One();
        _1Add = Add(grid_x, _0One);
        _2RangeInclusiveFloat = RangeInclusiveFloat(_1Add);
        _3BoxMin = BoxMin(x0);
        _4BoxMax = BoxMax(x0);
        _5Pass-through: function1 = (Single x0) => 
          {
            Vector3 _0Lerp;// 4:ArrayOfLerpedVectors->3:Lerp 89920
            _0Lerp = Lerp(_3BoxMin, _4BoxMax, x0);
            _0Lerp;
            };
        _6Map = Map(_2RangeInclusiveFloat, _5Pass-through: function1);
        _7Count = Count(_6Map);
        _8One = One();
        _9Subtract = Subtract(_7Count, _8One);
        _10Take = Take(_6Map, _9Subtract);
        _11One = One();
        _12Skip = Skip(_6Map, _11One);
        _13Combine = Combine(_10Take, _12Skip, (Vector3 x0, Vector3 x1) => 
          {
            BoundingBox _0Box;// 2:SubdivideBoxAlongDiagonal->8:Box 89929
            _0Box = Box(x0, x1);
            _0Box;
            });
        _14Map = Map(_13Combine, (BoundingBox x0) => 
          {
            Vector3 _0BoxMin;// 5:MatchBoxY->5:BoxMin 89935
            Single _1X;// 5:MatchBoxY->4:X 89934
            Vector3 _2BoxMin;// 5:MatchBoxY->11:BoxMin 89937
            Single _3Y;// 5:MatchBoxY->9:Y 89936
            Single _4Z;// 5:MatchBoxY->0:Z 89938
            Vector3 _5Vector3;// 5:MatchBoxY->8:Vector3 89933
            Vector3 _6BoxMax;// 5:MatchBoxY->6:BoxMax 89941
            Single _7X;// 5:MatchBoxY->14:X 89940
            Vector3 _8BoxMax;// 5:MatchBoxY->10:BoxMax 89943
            Single _9Y;// 5:MatchBoxY->13:Y 89942
            Single _10Z;// 5:MatchBoxY->12:Z 89944
            Vector3 _11Vector3;// 5:MatchBoxY->15:Vector3 89939
            BoundingBox _12Box;// 5:MatchBoxY->7:Box 89932
            _0BoxMin = BoxMin(x0);
            _1X = X(_0BoxMin);
            _2BoxMin = BoxMin(x0);
            _3Y = Y(_2BoxMin);
            _4Z = Z(_0BoxMin);
            _5Vector3 = Vector3(_1X, _3Y, _4Z);
            _6BoxMax = BoxMax(x0);
            _7X = X(_6BoxMax);
            _8BoxMax = BoxMax(x0);
            _9Y = Y(_8BoxMax);
            _10Z = Z(_6BoxMax);
            _11Vector3 = Vector3(_7X, _9Y, _10Z);
            _12Box = Box(_5Vector3, _11Vector3);
            _12Box;
            });
        _14Map;
        };
    _16Map = Map(_14Map, _15Pass-through: function1);
    _17Flatten = Flatten(_16Map);
    _18Pass-through: function1 = (BoundingBox x0) => 
      {
        Int32 _0One;// 10:PlusOne->1:One 89968
        Int32 _1Add;// 10:PlusOne->0:Add 89967
        IArray[Single] _2RangeInclusiveFloat;// 5:SampleLerp->2:RangeInclusiveFloat 89964
        Vector3 _3BoxMin;// 3:SubdivideBoxAlongDiagonal->2:BoxMin 89969
        Vector3 _4BoxMax;// 3:SubdivideBoxAlongDiagonal->3:BoxMax 89970
        Func[Single, Vector3] _5Pass-through: function1;// 0:Pass-through: function1 89962
        IArray[Vector3] _6Map;// 5:SampleLerp->3:Map 89963
        Int32 _7Count;// 3:LastIndex->2:Count 89957
        Int32 _8One;// 3:MinusOne->2:One 89956
        Int32 _9Subtract;// 3:MinusOne->1:Subtract 89955
        IArray[Vector3] _10Take;// 6:DropLast->2:Take 89952
        Int32 _11One;// 5:SkipOne->2:One 89973
        IArray[Vector3] _12Skip;// 5:SkipOne->3:Skip 89972
        IArray[BoundingBox] _13Combine;// 3:SubdivideBoxAlongDiagonal->7:Combine 89950
        IArray[BoundingBox] _14Map;// 6:SubdivideBoxAlongZ->0:Map 89947
        _0One = One();
        _1Add = Add(grid_z, _0One);
        _2RangeInclusiveFloat = RangeInclusiveFloat(_1Add);
        _3BoxMin = BoxMin(x0);
        _4BoxMax = BoxMax(x0);
        _5Pass-through: function1 = (Single x0) => 
          {
            Vector3 _0Lerp;// 4:ArrayOfLerpedVectors->3:Lerp 89965
            _0Lerp = Lerp(_3BoxMin, _4BoxMax, x0);
            _0Lerp;
            };
        _6Map = Map(_2RangeInclusiveFloat, _5Pass-through: function1);
        _7Count = Count(_6Map);
        _8One = One();
        _9Subtract = Subtract(_7Count, _8One);
        _10Take = Take(_6Map, _9Subtract);
        _11One = One();
        _12Skip = Skip(_6Map, _11One);
        _13Combine = Combine(_10Take, _12Skip, (Vector3 x0, Vector3 x1) => 
          {
            BoundingBox _0Box;// 3:SubdivideBoxAlongDiagonal->8:Box 89974
            _0Box = Box(x0, x1);
            _0Box;
            });
        _14Map = Map(_13Combine, (BoundingBox x0) => 
          {
            Vector3 _0BoxMin;// 5:MatchBoxZ->7:BoxMin 89980
            Single _1X;// 5:MatchBoxZ->6:X 89979
            Single _2Y;// 5:MatchBoxZ->10:Y 89981
            Vector3 _3BoxMin;// 5:MatchBoxZ->4:BoxMin 89983
            Single _4Z;// 5:MatchBoxZ->11:Z 89982
            Vector3 _5Vector3;// 5:MatchBoxZ->9:Vector3 89978
            Vector3 _6BoxMax;// 5:MatchBoxZ->8:BoxMax 89986
            Single _7X;// 5:MatchBoxZ->14:X 89985
            Single _8Y;// 5:MatchBoxZ->13:Y 89987
            Vector3 _9BoxMax;// 5:MatchBoxZ->3:BoxMax 89989
            Single _10Z;// 5:MatchBoxZ->12:Z 89988
            Vector3 _11Vector3;// 5:MatchBoxZ->15:Vector3 89984
            BoundingBox _12Box;// 5:MatchBoxZ->2:Box 89977
            _0BoxMin = BoxMin(x0);
            _1X = X(_0BoxMin);
            _2Y = Y(_0BoxMin);
            _3BoxMin = BoxMin(x0);
            _4Z = Z(_3BoxMin);
            _5Vector3 = Vector3(_1X, _2Y, _4Z);
            _6BoxMax = BoxMax(x0);
            _7X = X(_6BoxMax);
            _8Y = Y(_6BoxMax);
            _9BoxMax = BoxMax(x0);
            _10Z = Z(_9BoxMax);
            _11Vector3 = Vector3(_7X, _8Y, _10Z);
            _12Box = Box(_5Vector3, _11Vector3);
            _12Box;
            });
        _14Map;
        };
    _19Map = Map(_17Flatten, _18Pass-through: function1);
    _20Flatten = Flatten(_19Map);
    _21Two = Two();
    _22CreateCache = CreateCache(() => 
      {
        Boolean _0False;// 0:RayTraceCachedScene-ext->3:False 90026
        Tuple[RayTraceScene, Int32] _1Pass-through: any;// 0:Pass-through: any 90013
        _0False = False();
        _1Pass-through: any = RayTraceAddGeometry(RayTraceScene(_0False), mesh);
        _1Pass-through: any;
        }, (Tuple[RayTraceScene, Int32] x0) => 
      {
        if (caching)
          {
            x0;
            }else
          {
            Func[Tuple[RayTraceScene, Int32], Tuple[RayTraceScene, Int32]] _0Pass-through: function1;// 0:Pass-through: function1 90015
            Tuple[RayTraceScene, Int32] _1Apply1;// 12:CacheValueWhileTrueWithUpdate-ext->9:Apply1 90022
            _0Pass-through: function1 = (Tuple[RayTraceScene, Int32] x0) => 
              {
                RayTraceScene _0PairItem1;// 0:RayTraceCachedScene-ext->9:PairItem1 90028
                Int32 _1PairItem2;// 0:RayTraceCachedScene-ext->0:PairItem2 90030
                _0PairItem1 = PairItem1(x0);
                _1PairItem2 = PairItem2(x0);
                RayTraceUpdateGeometry(_0PairItem1, _1PairItem2, mesh);
                };
            _1Apply1 = Apply1(_0Pass-through: function1, x0);
            _1Apply1;
            };
        }, _21Two).SetId(state, 0);
    _23Zero = Zero();
    _24CachedValue = CachedValue(_22CreateCache, _23Zero);
    _25PairItem1 = PairItem1(_24CachedValue);
    _26Filter = Filter(_20Flatten, (BoundingBox x0) => 
      {
        BoundingSphere _0SphereFromBox;// 15:BoundingBoxCenter->2:SphereFromBox 90006
        Vector3 _1SphereCenter;// 15:BoundingBoxCenter->3:SphereCenter 90005
        Vector3 _2ZAxis;// 2:BoxInRayTraceSceneMesh-ext->7:ZAxis 90007
        Ray _3Ray;// 2:BoxInRayTraceSceneMesh-ext->2:Ray 90003
        Int32 _4Count;// 2:BoxInRayTraceSceneMesh-ext->21:Count 90001
        Int32 _5Two;// 2:BoxInRayTraceSceneMesh-ext->6:Two 90008
        Int32 _6Modulo;// 4:ModuloEquals->3:Modulo 90000
        Int32 _7One;// 2:BoxInRayTraceSceneMesh-ext->5:One 90009
        Boolean _8Equal;// 4:ModuloEquals->4:Equal 89999
        _0SphereFromBox = SphereFromBox(x0);
        _1SphereCenter = SphereCenter(_0SphereFromBox);
        _2ZAxis = ZAxis();
        _3Ray = Ray(_1SphereCenter, _2ZAxis);
        _4Count = Count(RayTraceAllIntersectingFaces(_25PairItem1, _3Ray));
        _5Two = Two();
        _6Modulo = Modulo(_4Count, _5Two);
        _7One = One();
        _8Equal = Equal(_6Modulo, _7One);
        _8Equal;
        });
    _27Constant = 100;
    _28Divide = Divide(box size, _27Constant);
    _29ParallelMap = ParallelMap(_26Filter, (BoundingBox x0) => 
      {
        BoundingSphere _0SphereFromBox;// 9:BoundingBoxCenter->2:SphereFromBox 90055
        Vector3 _1SphereCenter;// 9:BoundingBoxCenter->3:SphereCenter 90054
        Vector3 _2BoxMax;// 1:BoundingBoxExtent->1:BoxMax 90060
        Vector3 _3BoxMin;// 1:BoundingBoxExtent->2:BoxMin 90061
        Vector3 _4Subtract;// 1:BoundingBoxExtent->3:Subtract 90059
        Vector3 _5MultiplyByScalar;// 15:BoxScaleBy-ext->2:MultiplyByScalar 90057
        Single _6Constant;// 15:BoxScaleBy-ext->0:Constant 90062
        Vector3 _7DivideByScalar;// 15:BoxScaleBy-ext->5:DivideByScalar 90056
        Vector3 _8Subtract;// 15:BoxScaleBy-ext->4:Subtract 90052
        Vector3 _9Add;// 15:BoxScaleBy-ext->10:Add 90063
        BoundingBox _10Box;// 15:BoxScaleBy-ext->3:Box 90051
        QuadMesh _11BoxQuadMesh;// 7:BoxTriMesh->2:BoxQuadMesh 90048
        TriMesh _12Triangulate;// 7:BoxTriMesh->3:Triangulate 90047
        IArray[Int32] _13MeshIndices;// 4:HideEveryThirdEdge->2:MeshIndices 90038
        IArray[Int32] _14Indices;// 4:HideEveryThirdEdge->8:Indices 90037
        Int32 _15Constant;// 4:HideEveryThirdEdge->0:Constant 90045
        Int32 _16Constant;// 4:HideEveryThirdEdge->0:Constant 90046
        IArray[Boolean] _17Map;// 4:HideEveryThirdEdge->5:Map 90036
        TriMesh _18SetVisibleEdges;// 4:HideEveryThirdEdge->9:SetVisibleEdges 90035
        _0SphereFromBox = SphereFromBox(x0);
        _1SphereCenter = SphereCenter(_0SphereFromBox);
        _2BoxMax = BoxMax(x0);
        _3BoxMin = BoxMin(x0);
        _4Subtract = Subtract(_2BoxMax, _3BoxMin);
        _5MultiplyByScalar = MultiplyByScalar(_4Subtract, _28Divide);
        _6Constant = 2;
        _7DivideByScalar = DivideByScalar(_5MultiplyByScalar, _6Constant);
        _8Subtract = Subtract(_1SphereCenter, _7DivideByScalar);
        _9Add = Add(_1SphereCenter, _7DivideByScalar);
        _10Box = Box(_8Subtract, _9Add);
        _11BoxQuadMesh = BoxQuadMesh(_10Box);
        _12Triangulate = Triangulate(_11BoxQuadMesh);
        _13MeshIndices = MeshIndices(_12Triangulate);
        _14Indices = Indices(_13MeshIndices);
        _15Constant = 3;
        _16Constant = 2;
        _17Map = Map(_14Indices, (Int32 x0) => 
          {
            Int32 _0Modulo;// 6:ModuloEquals->3:Modulo 90044
            Boolean _1Equal;// 6:ModuloEquals->4:Equal 90043
            Boolean _2Not;// 4:HideEveryThirdEdge->7:Not 90039
            _0Modulo = Modulo(x0, _15Constant);
            _1Equal = Equal(_0Modulo, _16Constant);
            _2Not = Not(_1Equal);
            _2Not;
            });
        _18SetVisibleEdges = SetVisibleEdges(_12Triangulate, _17Map);
        _18SetVisibleEdges;
        });
    _30CombineAllMeshes = CombineAllMeshes(_29ParallelMap);
    _30CombineAllMeshes;
    }