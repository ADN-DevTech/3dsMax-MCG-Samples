(InstanceState state, Int32 segments, Single radius) => 
  {
    Boolean _0False;// 1:Sphere-ext->3:False 57297
    Boolean _1Not;// 0:QuadMeshFromUVs-ext->4:Not 57290
    IArray[Single] _4Pass-through: array;// 0:Pass-through: array 57264
    IArray[Single] _5Reverse;// 0:QuadMeshFromUVPoints-ext->13:Reverse 57279
    Boolean _6True;// 1:Sphere-ext->1:True 57298
    Boolean _7Not;// 0:QuadMeshFromUVs-ext->10:Not 57296
    IArray[Single] _10Pass-through: array;// 0:Pass-through: array 57265
    Func[Single, Single, Vector3] _11Pass-through: function2;// 0:Pass-through: function2 57263
    Func[Single, Single, Vector3] _12Pass-through: function2;// 0:Pass-through: function2 57272
    Func[Single, IArray[Vector3]] _13Pass-through: function1;// 0:Pass-through: function1 57274
    IArray[IArray[Vector3]] _14Map;// 4:FlatMap->4:Map 57276
    IArray[Vector3] _15Flatten;// 4:FlatMap->3:Flatten 57275
    Int32 _16Count;// 0:QuadMeshFromUVPoints-ext->14:Count 57284
    QuadMesh _17QuadMeshStrip;// 0:QuadMeshFromUVPoints-ext->5:QuadMeshStrip 57269
    TriMesh _18Triangulate;// 2:QuadToTriMesh-ext->4:Triangulate 57246
    IArray[Int32] _19MeshIndices;// 2:QuadToTriMesh-ext->3:MeshIndices 57249
    IArray[Int32] _20Indices;// 2:QuadToTriMesh-ext->8:Indices 57248
    Int32 _21Constant;// 2:QuadToTriMesh-ext->0:Constant 57254
    Int32 _22Constant;// 2:QuadToTriMesh-ext->0:Constant 57255
    Int32 _23Constant;// 2:QuadToTriMesh-ext->0:Constant 57257
    IArray[Boolean] _24Map;// 2:QuadToTriMesh-ext->5:Map 57247
    TriMesh _25SetVisibleEdges;// 2:QuadToTriMesh-ext->9:SetVisibleEdges 57245
    IArray[Vector3] _26MeshVertices;// 1:DeformMeshPoints->0:MeshVertices 57242
    Vector3 _27Vector3;// 5:ScalarToVector-ext->1:Vector3 57316
    Func[Vector3, Vector3] _28Pass-through: function1;// 0:Pass-through: function1 57239
    IArray[Vector3] _29Map;// 1:DeformMeshPoints->1:Map 57241
    TriMesh _30SetMeshVertices;// 1:DeformMeshPoints->4:SetMeshVertices 57240
    _0False = False();
    _1Not = Not(_0False);
    _4Pass-through: array = if (_1Not)
      {
        IArray[Single] _2RangeInclusiveFloat;// 1:RangeFloat-ext->1:RangeInclusiveFloat 57288
        _2RangeInclusiveFloat = RangeInclusiveFloat(segments);
        _2RangeInclusiveFloat;
        }else
      {
        IArray[Single] _3RangeExclusiveFloat;// 1:RangeFloat-ext->0:RangeExclusiveFloat 57289
        _3RangeExclusiveFloat = RangeExclusiveFloat(segments);
        _3RangeExclusiveFloat;
        };
    _5Reverse = Reverse(_4Pass-through: array);
    _6True = True();
    _7Not = Not(_6True);
    _10Pass-through: array = if (_7Not)
      {
        IArray[Single] _8RangeInclusiveFloat;// 9:RangeFloat-ext->1:RangeInclusiveFloat 57294
        _8RangeInclusiveFloat = RangeInclusiveFloat(segments);
        _8RangeInclusiveFloat;
        }else
      {
        IArray[Single] _9RangeExclusiveFloat;// 9:RangeFloat-ext->0:RangeExclusiveFloat 57295
        _9RangeExclusiveFloat = RangeExclusiveFloat(segments);
        _9RangeExclusiveFloat;
        };
    _11Pass-through: function2 = (Single x0, Single x1) => 
      {
        Single _0TwoPi;// 4:PointOnSphere-ext->7:TwoPi 57305
        Single _1Multiply;// 4:PointOnSphere-ext->6:Multiply 57304
        Single _2Cos;// 4:PointOnSphere-ext->14:Cos 57303
        Single _3Pi;// 4:PointOnSphere-ext->9:Pi 57309
        Single _4Multiply;// 4:PointOnSphere-ext->8:Multiply 57308
        Single _5HalfPi;// 4:PointOnSphere-ext->3:HalfPi 57310
        Single _6Subtract;// 4:PointOnSphere-ext->10:Subtract 57307
        Single _7Cos;// 4:PointOnSphere-ext->13:Cos 57306
        Single _8Multiply;// 4:PointOnSphere-ext->18:Multiply 57302
        Single _9Sin;// 4:PointOnSphere-ext->15:Sin 57312
        Single _10Multiply;// 4:PointOnSphere-ext->19:Multiply 57311
        Single _11Sin;// 4:PointOnSphere-ext->20:Sin 57313
        Vector3 _12Vector3;// 4:PointOnSphere-ext->12:Vector3 57301
        _0TwoPi = TwoPi();
        _1Multiply = Multiply(x0, _0TwoPi);
        _2Cos = Cos(_1Multiply);
        _3Pi = Pi();
        _4Multiply = Multiply(x1, _3Pi);
        _5HalfPi = HalfPi();
        _6Subtract = Subtract(_4Multiply, _5HalfPi);
        _7Cos = Cos(_6Subtract);
        _8Multiply = Multiply(_2Cos, _7Cos);
        _9Sin = Sin(_1Multiply);
        _10Multiply = Multiply(_9Sin, _7Cos);
        _11Sin = Sin(_6Subtract);
        _12Vector3 = Vector3(_8Multiply, _10Multiply, _11Sin);
        _12Vector3;
        };
    _12Pass-through: function2 = (Single x0, Single x1) => 
      {
        Single _0IgnoreFirst;// 0:QuadMeshFromUVPoints-ext->10:IgnoreFirst 57281
        Vector3 _1Apply2;// 0:QuadMeshFromUVPoints-ext->9:Apply2 57280
        _0IgnoreFirst = IgnoreFirst(x0, x1);
        _1Apply2 = Apply2(_11Pass-through: function2, _0IgnoreFirst, x0);
        _1Apply2;
        };
    _13Pass-through: function1 = (Single x0) => 
      {
        Func[Single, Vector3] _0Bind1of2;// 6:CartesianProduct->5:Bind1of2 57278
        IArray[Vector3] _1Map;// 6:CartesianProduct->1:Map 57277
        _0Bind1of2 = Bind1of2(_12Pass-through: function2, x0);
        _1Map = Map(_10Pass-through: array, _0Bind1of2);
        _1Map;
        };
    _14Map = Map(_5Reverse, _13Pass-through: function1);
    _15Flatten = Flatten(_14Map);
    _16Count = Count(_4Pass-through: array);
    _17QuadMeshStrip = QuadMeshStrip(_15Flatten, _16Count, _0False, _6True);
    _18Triangulate = Triangulate(_17QuadMeshStrip);
    _19MeshIndices = MeshIndices(_18Triangulate);
    _20Indices = Indices(_19MeshIndices);
    _21Constant = 6;
    _22Constant = 2;
    _23Constant = 3;
    _24Map = Map(_20Indices, (Int32 x0) => 
      {
        Int32 _0Modulo;// 2:QuadToTriMesh-ext->14:Modulo 57253
        Boolean _1Equal;// 2:QuadToTriMesh-ext->7:Equal 57252
        Boolean _2Equal;// 2:QuadToTriMesh-ext->13:Equal 57256
        Boolean _3OrElse;// 2:QuadToTriMesh-ext->12:OrElse 57251
        Boolean _4Not;// 2:QuadToTriMesh-ext->10:Not 57250
        _0Modulo = Modulo(x0, _21Constant);
        _1Equal = Equal(_0Modulo, _22Constant);
        _2Equal = Equal(_0Modulo, _23Constant);
        _3OrElse = OrElse(_1Equal, _2Equal);
        _4Not = Not(_3OrElse);
        _4Not;
        });
    _25SetVisibleEdges = SetVisibleEdges(_18Triangulate, _24Map);
    _26MeshVertices = MeshVertices(_25SetVisibleEdges);
    _27Vector3 = Vector3(radius, radius, radius);
    _28Pass-through: function1 = (Vector3 x0) => 
      {
        Vector3 _0Multiply;// 4:MeshScale-ext->2:Multiply 57243
        _0Multiply = Multiply(x0, _27Vector3);
        _0Multiply;
        };
    _29Map = Map(_26MeshVertices, _28Pass-through: function1);
    _30SetMeshVertices = SetMeshVertices(_25SetVisibleEdges, _29Map);
    _30SetMeshVertices;
    }