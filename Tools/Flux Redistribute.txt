(InstanceState state, Int32 Flux channel, TriMesh mesh, Boolean randomize, Int32 seed, Int32 count, Single min value, Single max value) => 
  {
    Int32 _0Constant;// 5:MapChannelOrGeometryGet-ext->0:Constant 100748
    Boolean _1Equal;// 5:MapChannelOrGeometryGet-ext->4:Equal 100747
    MapChannel _4Pass-through: any;// 0:Pass-through: any 100739
    Object _5Null;// 6:IsNullFix2-ext->3:Null 100743
    Object _6As;// 6:IsNullFix2-ext->23:As 100741
    Boolean _7Equal;// 6:IsNullFix2-ext->1:Equal 100740
    Boolean _8Not;// 4:MapChannelExists-ext->4:Not 100738
    Int32 _9One;// 13:PlusOne->1:One 100798
    Int32 _10Add;// 13:PlusOne->0:Add 100797
    TriMesh _38Pass-through: TriMesh;// 0:Pass-through: TriMesh 100714
    Single _43Constant;// 18:DivideBy100-ext->0:Constant 100825
    Single _44Divide;// 18:DivideBy100-ext->2:Divide 100824
    Single _45Constant;// 19:DivideBy100-ext->0:Constant 100829
    Single _46Divide;// 19:DivideBy100-ext->2:Divide 100828
    IArray[Single] _47Map;// 5:GenerateFloats-ext->19:Map 100805
    MapChannel _48GetMapChannel;// 0:MatricesFromMapChannel-ext->9:GetMapChannel 100902
    IArray[Vector3] _49MapChannelVertexBuffer;// 0:MatricesFromMapChannel-ext->8:MapChannelVertexBuffer 100901
    Int32 _50Count;// 2:Slices->2:Count 100898
    Int32 _51Constant;// 0:MatricesFromMapChannel-ext->0:Constant 100903
    Int32 _52Divide;// 2:Slices->3:Divide 100897
    IArray[Int32] _53Range;// 2:Slices->4:Range 100896
    IArray[IArray[Vector3]] _54Map;// 2:Slices->5:Map 100895
    IArray[Matrix] _55Map;// 0:MatricesFromMapChannel-ext->5:Map 100892
    IArray[Matrix] _56Map;// 2:Map 100799
    Func[Matrix, IArray[Vector3]] _57Pass-through: function1;// 0:Pass-through: function1 100719
    IArray[IArray[Vector3]] _58Map;// 5:FlatMap->4:Map 100721
    IArray[Vector3] _59Flatten;// 5:FlatMap->3:Flatten 100720
    IArray[Int32] _60MeshIndices;// 13:MapChannelStoreMatrices-ext->0:MeshIndices 100730
    TriMesh _61SetMapChannel;// 13:MapChannelStoreMatrices-ext->7:SetMapChannel 100717
    _0Constant = -3;
    _1Equal = Equal(Flux channel, _0Constant);
    _4Pass-through: any = if (_1Equal)
      {
        MapChannel _2TopologyChannel;// 5:MapChannelOrGeometryGet-ext->6:TopologyChannel 100749
        _2TopologyChannel = TopologyChannel(mesh);
        _2TopologyChannel;
        }else
      {
        MapChannel _3GetMapChannel;// 5:MapChannelOrGeometryGet-ext->3:GetMapChannel 100750
        _3GetMapChannel = GetMapChannel(mesh, Flux channel);
        _3GetMapChannel;
        };
    _5Null = Null();
    _6As = As(_4Pass-through: any, (Object x0) => 
      {
        Object _0IgnoreFirst;// 6:IsNullFix2-ext->5:IgnoreFirst 100742
        _0IgnoreFirst = IgnoreFirst(x0, _5Null);
        _0IgnoreFirst;
        });
    _7Equal = Equal(_6As, _5Null);
    _8Not = Not(_7Equal);
    _9One = One();
    _10Add = Add(Flux channel, _9One);
    _38Pass-through: TriMesh = if (_8Not)
      {
        Int32 _11Constant;// 7:MapChannelOrGeometrySet-ext->0:Constant 100760
        Boolean _12Equal;// 7:MapChannelOrGeometrySet-ext->6:Equal 100759
        Int32 _13Constant;// 0:MapChannelOrGeometryGet-ext->0:Constant 100770
        Boolean _14Equal;// 0:MapChannelOrGeometryGet-ext->4:Equal 100769
        MapChannel _17Pass-through: MapChannel;// 0:Pass-through: MapChannel 100752
        IArray[Vector3] _18MapChannelVertexBuffer;// 8:MapChannelAssign-ext->3:MapChannelVertexBuffer 100764
        IArray[Int32] _21MapChannelIndexBuffer;// 8:MapChannelAssign-ext->4:MapChannelIndexBuffer 100765
        _11Constant = -3;
        _12Equal = Equal(_11Constant, _10Add);
        _13Constant = -3;
        _14Equal = Equal(Flux channel, _13Constant);
        _17Pass-through: MapChannel = if (_14Equal)
          {
            MapChannel _15TopologyChannel;// 0:MapChannelOrGeometryGet-ext->6:TopologyChannel 100771
            _15TopologyChannel = TopologyChannel(mesh);
            _15TopologyChannel;
            }else
          {
            MapChannel _16GetMapChannel;// 0:MapChannelOrGeometryGet-ext->3:GetMapChannel 100772
            _16GetMapChannel = GetMapChannel(mesh, Flux channel);
            _16GetMapChannel;
            };
        _18MapChannelVertexBuffer = MapChannelVertexBuffer(_17Pass-through: MapChannel);
        _21MapChannelIndexBuffer = MapChannelIndexBuffer(_17Pass-through: MapChannel);
        if (_12Equal)
          {
            MeshData _22MeshData;// 7:MapChannelOrGeometrySet-ext->9:MeshData 100762
            TriMesh _23CreateMeshWithMeshData;// 7:MapChannelOrGeometrySet-ext->8:CreateMeshWithMeshData 100761
            _22MeshData = MeshData(mesh);
            _23CreateMeshWithMeshData = CreateMeshWithMeshData(_18MapChannelVertexBuffer, _21MapChannelIndexBuffer, _22MeshData);
            _23CreateMeshWithMeshData;
            }else
          {
            TriMesh _24SetMapChannel;// 7:MapChannelOrGeometrySet-ext->0:SetMapChannel 100763
            _24SetMapChannel = SetMapChannel(mesh, _10Add, _18MapChannelVertexBuffer, _21MapChannelIndexBuffer);
            _24SetMapChannel;
            };
        }else
      {
        Int32 _25Constant;// 10:MapChannelOrGeometrySet-ext->0:Constant 100781
        Boolean _26Equal;// 10:MapChannelOrGeometrySet-ext->6:Equal 100780
        Single _27Constant;// 5:Origin->0:Constant 100787
        Vector3 _28Vector3;// 5:Origin->1:Vector3 100786
        IArray[Vector3] _29Unit;// 2:MapChannelClear-ext->4:Unit 100785
        Int32 _30Zero;// 2:MapChannelClear-ext->9:Zero 100789
        Int32 _31FaceCount;// 2:MapChannelClear-ext->6:FaceCount 100793
        Int32 _32Constant;// 1:Three->0:Constant 100792
        Int32 _33Multiply;// 7:MultiplyByThree->2:Multiply 100791
        IArray[Int32] _34ArrayOf;// 2:MapChannelClear-ext->8:ArrayOf 100788
        _25Constant = -3;
        _26Equal = Equal(_25Constant, _10Add);
        _27Constant = 0;
        _28Vector3 = Vector3(_27Constant, _27Constant, _27Constant);
        _29Unit = Unit(_28Vector3);
        _30Zero = Zero();
        _31FaceCount = FaceCount(mesh);
        _32Constant = 3;
        _33Multiply = Multiply(_31FaceCount, _32Constant);
        _34ArrayOf = ArrayOf(_30Zero, _33Multiply);
        if (_26Equal)
          {
            MeshData _35MeshData;// 10:MapChannelOrGeometrySet-ext->9:MeshData 100783
            TriMesh _36CreateMeshWithMeshData;// 10:MapChannelOrGeometrySet-ext->8:CreateMeshWithMeshData 100782
            _35MeshData = MeshData(mesh);
            _36CreateMeshWithMeshData = CreateMeshWithMeshData(_29Unit, _34ArrayOf, _35MeshData);
            _36CreateMeshWithMeshData;
            }else
          {
            TriMesh _37SetMapChannel;// 10:MapChannelOrGeometrySet-ext->0:SetMapChannel 100784
            _37SetMapChannel = SetMapChannel(mesh, _10Add, _29Unit, _34ArrayOf);
            _37SetMapChannel;
            };
        };
    _43Constant = 100;
    _44Divide = Divide(min value, _43Constant);
    _45Constant = 100;
    _46Divide = Divide(max value, _45Constant);
    _47Map = Map(if (randomize)
      {
        Random _39RandomNumberGenerator;// 5:GenerateFloats-ext->13:RandomNumberGenerator 100812
        Func[Single] _40Bind;// 16:PseudoRandomFloats-ext->2:Bind 100810
        IArray[Single] _41ArrayOfFunction;// 16:PseudoRandomFloats-ext->3:ArrayOfFunction 100809
        _39RandomNumberGenerator = RandomNumberGenerator(seed);
        _40Bind = Bind((Random x0) => 
          {
            PseudoRandomFloat(x0);
            }, _39RandomNumberGenerator);
        _41ArrayOfFunction = ArrayOfFunction(_40Bind, count);
        _41ArrayOfFunction;
        }else
      {
        IArray[Single] _42RangeExclusiveFloat;// 5:GenerateFloats-ext->17:RangeExclusiveFloat 100813
        _42RangeExclusiveFloat = RangeExclusiveFloat(count);
        _42RangeExclusiveFloat;
        }, (Single x0) => 
      {
        Single _0Subtract;// 18:ScaleFloat->6:Subtract 100819
        Single _1Multiply;// 18:ScaleFloat->8:Multiply 100818
        Single _2Add;// 18:ScaleFloat->9:Add 100817
        _0Subtract = Subtract(_46Divide, _44Divide);
        _1Multiply = Multiply(x0, _0Subtract);
        _2Add = Add(_44Divide, _1Multiply);
        _2Add;
        });
    _48GetMapChannel = GetMapChannel(mesh, Flux channel);
    _49MapChannelVertexBuffer = MapChannelVertexBuffer(_48GetMapChannel);
    _50Count = Count(_49MapChannelVertexBuffer);
    _51Constant = 4;
    _52Divide = Divide(_50Count, _51Constant);
    _53Range = Range(_52Divide);
    _54Map = Map(_53Range, (Int32 x0) => 
      {
        Int32 _0Multiply;// 2:Slices->6:Multiply 100900
        IArray[Vector3] _1Slice;// 2:Slices->0:Slice 100899
        _0Multiply = Multiply(_51Constant, x0);
        _1Slice = Slice(_49MapChannelVertexBuffer, _0Multiply, _51Constant);
        _1Slice;
        });
    _55Map = Map(_54Map, (IArray[Vector3] x0) => 
      {
        Matrix _0MatrixIdentity;// 0:SetMatrixFrom3Rows->23:MatrixIdentity 100912
        Int32 _1One;// 0:SetMatrixFrom3Rows->24:One 100913
        Int32 _2Zero;// 6:MatrixFromRows-ext->7:Zero 100917
        Vector3 _3At;// 6:MatrixFromRows-ext->3:At 100916
        Matrix _4SetMatrixRow;// 0:SetMatrixFrom3Rows->22:SetMatrixRow 100911
        Int32 _5Two;// 0:SetMatrixFrom3Rows->26:Two 100914
        Int32 _6One;// 8:PlusOne->1:One 100921
        Int32 _7Add;// 8:PlusOne->0:Add 100920
        Vector3 _8At;// 6:MatrixFromRows-ext->4:At 100918
        Matrix _9SetMatrixRow;// 0:SetMatrixFrom3Rows->27:SetMatrixRow 100910
        Int32 _10Constant;// 25:Three->0:Constant 100915
        Int32 _11One;// 9:PlusOne->1:One 100925
        Int32 _12Add;// 9:PlusOne->0:Add 100924
        Vector3 _13At;// 6:MatrixFromRows-ext->5:At 100922
        Matrix _14SetMatrixRow;// 0:SetMatrixFrom3Rows->28:SetMatrixRow 100909
        Int32 _15One;// 10:PlusOne->1:One 100929
        Int32 _16Add;// 10:PlusOne->0:Add 100928
        Vector3 _17At;// 6:MatrixFromRows-ext->6:At 100926
        Matrix _18SetMatrixTranslation;// 6:MatrixFromRows-ext->2:SetMatrixTranslation 100905
        _0MatrixIdentity = MatrixIdentity();
        _1One = One();
        _2Zero = Zero();
        _3At = At(x0, _2Zero);
        _4SetMatrixRow = SetMatrixRow(_0MatrixIdentity, _1One, _3At);
        _5Two = Two();
        _6One = One();
        _7Add = Add(_2Zero, _6One);
        _8At = At(x0, _7Add);
        _9SetMatrixRow = SetMatrixRow(_4SetMatrixRow, _5Two, _8At);
        _10Constant = 3;
        _11One = One();
        _12Add = Add(_7Add, _11One);
        _13At = At(x0, _12Add);
        _14SetMatrixRow = SetMatrixRow(_9SetMatrixRow, _10Constant, _13At);
        _15One = One();
        _16Add = Add(_12Add, _15One);
        _17At = At(x0, _16Add);
        _18SetMatrixTranslation = SetMatrixTranslation(_14SetMatrixRow, _17At);
        _18SetMatrixTranslation;
        });
    _56Map = Map(_47Map, (Single x0) => 
      {
        Int32 _0Count;// 22:LerpArrayMatrices-ext->7:Count 100862
        Int32 _1One;// 16:MinusOne->2:One 100861
        Int32 _2Subtract;// 16:MinusOne->1:Subtract 100860
        Single _3IntAsFloat;// 22:LerpArrayMatrices-ext->2:IntAsFloat 100858
        Single _4Multiply;// 22:LerpArrayMatrices-ext->3:Multiply 100857
        Int32 _5Floor;// 22:LerpArrayMatrices-ext->1:Floor 100856
        Int32 _6Zero;// 10:ClampIntMax->1:Zero 100855
        Int32 _7One;// 11:MinusOne->2:One 100865
        Int32 _8Subtract;// 11:MinusOne->1:Subtract 100864
        Int32 _9ClampInt;// 10:ClampIntMax->0:ClampInt 100854
        Matrix _10At;// 22:LerpArrayMatrices-ext->4:At 100851
        Vector3 _11GetMatrixScaling;// 12:MatrixComponentsLerp-ext->6:GetMatrixScaling 100843
        Int32 _12One;// 6:PlusOne->1:One 100869
        Int32 _13Add;// 6:PlusOne->0:Add 100868
        Matrix _14At;// 22:LerpArrayMatrices-ext->8:At 100866
        Vector3 _15GetMatrixScaling;// 12:MatrixComponentsLerp-ext->7:GetMatrixScaling 100844
        Single _16IntAsFloat;// 22:LerpArrayMatrices-ext->12:IntAsFloat 100888
        Single _17Subtract;// 14:FloatReverseLerp-ext->3:Subtract 100886
        Single _18IntAsFloat;// 22:LerpArrayMatrices-ext->13:IntAsFloat 100889
        Single _19Subtract;// 14:FloatReverseLerp-ext->4:Subtract 100887
        Single _20Abs;// 3:FloatIsSmall-ext->4:Abs 100882
        Single _21Constant;// 2:VectorLengthEpsilon-ext->0:Constant 100883
        Boolean _22LessThanOrEqual;// 3:FloatIsSmall-ext->1:LessThanOrEqual 100881
        Single _25IgnoreFirst;// 9:DivideDefault-ext->8:IgnoreFirst 100878
        Vector3 _26Lerp;// 12:MatrixComponentsLerp-ext->11:Lerp 100842
        Quaternion _27GetMatrixRotation;// 12:MatrixComponentsLerp-ext->4:GetMatrixRotation 100846
        Quaternion _28GetMatrixRotation;// 12:MatrixComponentsLerp-ext->5:GetMatrixRotation 100847
        Quaternion _29QuaternionLerp;// 12:MatrixComponentsLerp-ext->9:QuaternionLerp 100845
        Vector3 _30GetMatrixTranslation;// 12:MatrixComponentsLerp-ext->2:GetMatrixTranslation 100849
        Vector3 _31GetMatrixTranslation;// 12:MatrixComponentsLerp-ext->3:GetMatrixTranslation 100850
        Vector3 _32Lerp;// 12:MatrixComponentsLerp-ext->10:Lerp 100848
        Matrix _33ScalingRotationTranslationMatrix;// 12:MatrixComponentsLerp-ext->14:ScalingRotationTranslationMatrix 100841
        _0Count = Count(_55Map);
        _1One = One();
        _2Subtract = Subtract(_0Count, _1One);
        _3IntAsFloat = IntAsFloat(_2Subtract);
        _4Multiply = Multiply(_3IntAsFloat, x0);
        _5Floor = Floor(_4Multiply);
        _6Zero = Zero();
        _7One = One();
        _8Subtract = Subtract(_2Subtract, _7One);
        _9ClampInt = ClampInt(_5Floor, _6Zero, _8Subtract);
        _10At = At(_55Map, _9ClampInt);
        _11GetMatrixScaling = GetMatrixScaling(_10At);
        _12One = One();
        _13Add = Add(_9ClampInt, _12One);
        _14At = At(_55Map, _13Add);
        _15GetMatrixScaling = GetMatrixScaling(_14At);
        _16IntAsFloat = IntAsFloat(_9ClampInt);
        _17Subtract = Subtract(_4Multiply, _16IntAsFloat);
        _18IntAsFloat = IntAsFloat(_13Add);
        _19Subtract = Subtract(_18IntAsFloat, _16IntAsFloat);
        _20Abs = Abs(_19Subtract);
        _21Constant = 1E-06;
        _22LessThanOrEqual = LessThanOrEqual(_20Abs, _21Constant);
        _25IgnoreFirst = IgnoreFirst(_17Subtract, if (_22LessThanOrEqual)
          {
            Single _23FloatZero;// 5:DivideDefaultToZero-ext->6:FloatZero 100885
            _23FloatZero = FloatZero();
            _23FloatZero;
            }else
          {
            Single _24Divide;// 9:DivideDefault-ext->5:Divide 100884
            _24Divide = Divide(_17Subtract, _19Subtract);
            _24Divide;
            });
        _26Lerp = Lerp(_11GetMatrixScaling, _15GetMatrixScaling, _25IgnoreFirst);
        _27GetMatrixRotation = GetMatrixRotation(_10At);
        _28GetMatrixRotation = GetMatrixRotation(_14At);
        _29QuaternionLerp = QuaternionLerp(_27GetMatrixRotation, _28GetMatrixRotation, _25IgnoreFirst);
        _30GetMatrixTranslation = GetMatrixTranslation(_10At);
        _31GetMatrixTranslation = GetMatrixTranslation(_14At);
        _32Lerp = Lerp(_30GetMatrixTranslation, _31GetMatrixTranslation, _25IgnoreFirst);
        _33ScalingRotationTranslationMatrix = ScalingRotationTranslationMatrix(_26Lerp, _29QuaternionLerp, _32Lerp);
        _33ScalingRotationTranslationMatrix;
        });
    _57Pass-through: function1 = (Matrix x0) => 
      {
        Int32 _0Constant;// 3:MatrixRows-ext->0:Constant 100725
        IArray[Int32] _1Range;// 3:MatrixRows-ext->1:Range 100724
        IArray[Vector3] _2Map;// 3:MatrixRows-ext->3:Map 100723
        _0Constant = 4;
        _1Range = Range(_0Constant);
        _2Map = Map(_1Range, (Int32 x0) => 
          {
            Int32 _0One;// 5:PlusOne->1:One 100729
            Int32 _1Add;// 5:PlusOne->0:Add 100728
            Vector3 _2MatrixRow;// 3:MatrixRows-ext->4:MatrixRow 100726
            _0One = One();
            _1Add = Add(x0, _0One);
            _2MatrixRow = MatrixRow(_1Add, x0);
            _2MatrixRow;
            });
        _2Map;
        };
    _58Map = Map(_56Map, _57Pass-through: function1);
    _59Flatten = Flatten(_58Map);
    _60MeshIndices = MeshIndices(_38Pass-through: TriMesh);
    _61SetMapChannel = SetMapChannel(_38Pass-through: TriMesh, Flux channel, _59Flatten, _60MeshIndices);
    _61SetMapChannel;
    }