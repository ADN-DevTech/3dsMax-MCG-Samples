(InstanceState state, TriMesh mesh, INode origin, Matrix modifierTransform, Boolean updateCache, INode obstacle) => 
  {
    IArray[Vector3] _0MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101495
    Boolean _1IsValidNode;// 0:NodePosition-ext->2:IsValidNode 1101574
    Vector3 _2IfThen;// 0:NodePosition-ext->4:IfThen 1101573
    Matrix _3InvertMatrix;// 23:MeshMoveToNewOrigin-ext->4:InvertMatrix 1101498
    Vector3 _4Transform;// 23:MeshMoveToNewOrigin-ext->5:Transform 1101497
    Func[Vector3, Vector3] _5Pass-through: function1;// 0:Pass-through: function1 1101492
    IArray[Vector3] _6Map;// 0:DeformMeshPoints->1:Map 1101494
    TriMesh _7SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101493
    String _8Constant;// 0:HasPerVertexChannel->0:Constant 1101432
    Int32 _9Zero;// 4:HasSoftSelection->3:Zero 1101434
    String _10ToString;// 0:HasPerVertexChannel->7:ToString 1101433
    String _11ConcatenateStrings;// 0:HasPerVertexChannel->3:ConcatenateStrings 1101431
    Boolean _12IsChannelAvailable;// 0:HasPerVertexChannel->4:IsChannelAvailable 1101430
    TriMesh _13IfThen;// 6:MeshSetVertices-ext->10:IfThen 1101426
    _0MeshVertices = MeshVertices(mesh);
    _1IsValidNode = IsValidNode(origin);
    _2IfThen = IfThen(_1IsValidNode, () => 
      {
        Vector3 _0NodePosition;// 0:NodePosition-ext->8:NodePosition 1101575
        _0NodePosition = NodePosition(origin);
        _0NodePosition;
        }, () => 
      {
        Single _0Constant;// 1:Origin->0:Constant 1101578
        Vector3 _1Vector3;// 1:Origin->1:Vector3 1101577
        _0Constant = 0;
        _1Vector3 = Vector3(_0Constant, _0Constant, _0Constant);
        _1Vector3;
        });
    _3InvertMatrix = InvertMatrix(modifierTransform);
    _4Transform = Transform(_2IfThen, _3InvertMatrix);
    _5Pass-through: function1 = (Vector3 x0) => 
      {
        Vector3 _0Add;// 3:OffsetMesh->2:Add 1101496
        _0Add = Add(x0, _4Transform);
        _0Add;
        };
    _6Map = Map(_0MeshVertices, _5Pass-through: function1);
    _7SetMeshVertices = SetMeshVertices(mesh, _6Map);
    _8Constant = per-vertex data channel ;
    _9Zero = Zero();
    _10ToString = ToString(_9Zero);
    _11ConcatenateStrings = ConcatenateStrings(_8Constant, _10ToString);
    _12IsChannelAvailable = IsChannelAvailable(_7SetMeshVertices, _11ConcatenateStrings);
    _13IfThen = IfThen(_12IsChannelAvailable, () => 
      {
        IArray[Vector3] _0MeshVertices;// 6:MeshSetVertices-ext->0:MeshVertices 1101441
        IArray[Vector3] _1MeshVertices;// 7:MeshMoveVerticesLimited-ext->3:MeshVertices 1101447
        IArray[Vector3] _2MeshVertices;// 5:MeshMoveVerticesLimitedTowardsNode-ext->4:MeshVertices 1101499
        Cache[Tuple[TriMesh, RayTraceScene]] _3IfThen;// 22:RayTraceSceneCached-ext->14:IfThen 1101509
        Int32 _4Zero;// 7:ExtractCurrentValueFromCache->3:Zero 1101508
        Tuple[TriMesh, RayTraceScene] _5CachedValue;// 7:ExtractCurrentValueFromCache->1:CachedValue 1101507
        RayTraceScene _6PairItem2;// 22:RayTraceSceneCached-ext->28:PairItem2 1101505
        Int32 _7Zero;// 22:RayTraceSceneCached-ext->21:Zero 1101535
        TriMesh _8PairItem1;// 22:RayTraceSceneCached-ext->26:PairItem1 1101544
        IArray[Vector3] _9MeshVertices;// 2:DeformMeshPoints->0:MeshVertices 1101542
        Boolean _10IsValidNode;// 6:NodeTransformOrIdentity-ext->1:IsValidNode 1101566
        Matrix _11IfThen;// 6:NodeTransformOrIdentity-ext->2:IfThen 1101565
        Matrix _12InvertMatrix;// 5:MeshMoveVerticesLimitedTowardsNode-ext->19:InvertMatrix 1101569
        Matrix _13Multiply;// 5:MeshMoveVerticesLimitedTowardsNode-ext->18:Multiply 1101563
        Func[Vector3, Vector3] _14Pass-through: function1;// 0:Pass-through: function1 1101539
        IArray[Vector3] _15Map;// 2:DeformMeshPoints->1:Map 1101541
        TriMesh _16SetMeshVertices;// 2:DeformMeshPoints->4:SetMeshVertices 1101540
        RayTraceScene _17PairItem1;// 22:RayTraceSceneCached-ext->16:PairItem1 1101503
        IArray[Vector3] _18Combine;// 7:MeshMoveVerticesLimited-ext->5:Combine 1101446
        Int32 _19Zero;// 7:SoftSelection->2:Zero 1101444
        IArray[Single] _20PerVertexData;// 7:SoftSelection->3:PerVertexData 1101443
        IArray[Vector3] _21Combine3;// 1:LerpVectors-ext->10:Combine3 1101439
        TriMesh _22SetMeshVertices;// 6:MeshSetVertices-ext->6:SetMeshVertices 1101435
        _0MeshVertices = MeshVertices(_7SetMeshVertices);
        _1MeshVertices = MeshVertices(_7SetMeshVertices);
        _2MeshVertices = MeshVertices(mesh);
        _3IfThen = IfThen(updateCache, () => 
          {
            Cache[Tuple[TriMesh, RayTraceScene]] _0CreateStaticCache;// 22:RayTraceSceneCached-ext->13:CreateStaticCache 1101511
            Cache[Tuple[TriMesh, RayTraceScene]] _1ForceUpdateCache;// 22:RayTraceSceneCached-ext->15:ForceUpdateCache 1101510
            _0CreateStaticCache = CreateStaticCache(() => 
              {
                Boolean _0IsValidNode;// 13:NodeMeshOrDefault-ext->1:IsValidNode 1101548
                TriMesh _10Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101501
                Int32 _11FaceCount;// 22:RayTraceSceneCached-ext->19:FaceCount 1101515
                Int32 _12Zero;// 22:RayTraceSceneCached-ext->22:Zero 1101516
                Boolean _13Equal;// 22:RayTraceSceneCached-ext->20:Equal 1101514
                Boolean _22False;// 11:RayTraceScene-ext->1:False 1101534
                TriMesh _31Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101530
                RayTraceScene _32PairItem1;// 11:RayTraceScene-ext->10:PairItem1 1101531
                Tuple[TriMesh, RayTraceScene] _33Pair;// 22:RayTraceSceneCached-ext->6:Pair 1101512
                _0IsValidNode = IsValidNode(obstacle);
                _10Pass-through: TriMesh = if (_0IsValidNode)
                  {
                    TriMesh _1MeshFromNode;// 13:NodeMeshOrDefault-ext->2:MeshFromNode 1101549
                    _1MeshFromNode = MeshFromNode(obstacle);
                    _1MeshFromNode;
                    }else
                  {
                    Single _2FloatZero;// 5:MeshMoveVerticesLimitedTowardsNode-ext->9:FloatZero 1101559
                    TriMesh _3Tetrahedron;// 5:MeshMoveVerticesLimitedTowardsNode-ext->8:Tetrahedron 1101558
                    IArray[Vector3] _4MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101556
                    Single _5Constant;// 5:MeshMoveVerticesLimitedTowardsNode-ext->0:Constant 1101562
                    Vector3 _6Vector3;// 15:ScalarToVector-ext->1:Vector3 1101561
                    Func[Vector3, Vector3] _7Pass-through: function1;// 0:Pass-through: function1 1101553
                    IArray[Vector3] _8Map;// 0:DeformMeshPoints->1:Map 1101555
                    TriMesh _9SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101554
                    _2FloatZero = FloatZero();
                    _3Tetrahedron = Tetrahedron(_2FloatZero);
                    _4MeshVertices = MeshVertices(_3Tetrahedron);
                    _5Constant = -1E+07;
                    _6Vector3 = Vector3(_5Constant, _5Constant, _5Constant);
                    _7Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 11:OffsetMesh->2:Add 1101557
                        _0Add = Add(x0, _6Vector3);
                        _0Add;
                        };
                    _8Map = Map(_4MeshVertices, _7Pass-through: function1);
                    _9SetMeshVertices = SetMeshVertices(_3Tetrahedron, _8Map);
                    _9SetMeshVertices;
                    };
                _11FaceCount = FaceCount(_10Pass-through: TriMesh);
                _12Zero = Zero();
                _13Equal = Equal(_11FaceCount, _12Zero);
                _22False = False();
                _31Pass-through: TriMesh = if (_13Equal)
                  {
                    Single _23FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _24Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _25MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _26Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _27Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _28Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _29Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _30SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _23FloatZero = FloatZero();
                    _24Tetrahedron = Tetrahedron(_23FloatZero);
                    _25MeshVertices = MeshVertices(_24Tetrahedron);
                    _26Constant = -1E+07;
                    _27Vector3 = Vector3(_26Constant, _26Constant, _26Constant);
                    _28Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _27Vector3);
                        _0Add;
                        };
                    _29Map = Map(_25MeshVertices, _28Pass-through: function1);
                    _30SetMeshVertices = SetMeshVertices(_24Tetrahedron, _29Map);
                    _30SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    };
                _32PairItem1 = PairItem1(RayTraceAddGeometry(RayTraceScene(_22False), _31Pass-through: TriMesh));
                _33Pair = Pair(if (_13Equal)
                  {
                    Single _14FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _15Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _16MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _17Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _18Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _19Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _20Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _21SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _14FloatZero = FloatZero();
                    _15Tetrahedron = Tetrahedron(_14FloatZero);
                    _16MeshVertices = MeshVertices(_15Tetrahedron);
                    _17Constant = -1E+07;
                    _18Vector3 = Vector3(_17Constant, _17Constant, _17Constant);
                    _19Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _18Vector3);
                        _0Add;
                        };
                    _20Map = Map(_16MeshVertices, _19Pass-through: function1);
                    _21SetMeshVertices = SetMeshVertices(_15Tetrahedron, _20Map);
                    _21SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    }, _32PairItem1);
                _33Pair;
                }).SetId(state, 0);
            _1ForceUpdateCache = ForceUpdateCache(_0CreateStaticCache);
            _1ForceUpdateCache;
            }, () => 
          {
            Cache[Tuple[TriMesh, RayTraceScene]] _0CreateStaticCache;// 22:RayTraceSceneCached-ext->13:CreateStaticCache 1101511
            _0CreateStaticCache = CreateStaticCache(() => 
              {
                Boolean _0IsValidNode;// 13:NodeMeshOrDefault-ext->1:IsValidNode 1101548
                TriMesh _10Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101501
                Int32 _11FaceCount;// 22:RayTraceSceneCached-ext->19:FaceCount 1101515
                Int32 _12Zero;// 22:RayTraceSceneCached-ext->22:Zero 1101516
                Boolean _13Equal;// 22:RayTraceSceneCached-ext->20:Equal 1101514
                Boolean _22False;// 11:RayTraceScene-ext->1:False 1101534
                TriMesh _31Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101530
                RayTraceScene _32PairItem1;// 11:RayTraceScene-ext->10:PairItem1 1101531
                Tuple[TriMesh, RayTraceScene] _33Pair;// 22:RayTraceSceneCached-ext->6:Pair 1101512
                _0IsValidNode = IsValidNode(obstacle);
                _10Pass-through: TriMesh = if (_0IsValidNode)
                  {
                    TriMesh _1MeshFromNode;// 13:NodeMeshOrDefault-ext->2:MeshFromNode 1101549
                    _1MeshFromNode = MeshFromNode(obstacle);
                    _1MeshFromNode;
                    }else
                  {
                    Single _2FloatZero;// 5:MeshMoveVerticesLimitedTowardsNode-ext->9:FloatZero 1101559
                    TriMesh _3Tetrahedron;// 5:MeshMoveVerticesLimitedTowardsNode-ext->8:Tetrahedron 1101558
                    IArray[Vector3] _4MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101556
                    Single _5Constant;// 5:MeshMoveVerticesLimitedTowardsNode-ext->0:Constant 1101562
                    Vector3 _6Vector3;// 15:ScalarToVector-ext->1:Vector3 1101561
                    Func[Vector3, Vector3] _7Pass-through: function1;// 0:Pass-through: function1 1101553
                    IArray[Vector3] _8Map;// 0:DeformMeshPoints->1:Map 1101555
                    TriMesh _9SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101554
                    _2FloatZero = FloatZero();
                    _3Tetrahedron = Tetrahedron(_2FloatZero);
                    _4MeshVertices = MeshVertices(_3Tetrahedron);
                    _5Constant = -1E+07;
                    _6Vector3 = Vector3(_5Constant, _5Constant, _5Constant);
                    _7Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 11:OffsetMesh->2:Add 1101557
                        _0Add = Add(x0, _6Vector3);
                        _0Add;
                        };
                    _8Map = Map(_4MeshVertices, _7Pass-through: function1);
                    _9SetMeshVertices = SetMeshVertices(_3Tetrahedron, _8Map);
                    _9SetMeshVertices;
                    };
                _11FaceCount = FaceCount(_10Pass-through: TriMesh);
                _12Zero = Zero();
                _13Equal = Equal(_11FaceCount, _12Zero);
                _22False = False();
                _31Pass-through: TriMesh = if (_13Equal)
                  {
                    Single _23FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _24Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _25MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _26Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _27Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _28Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _29Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _30SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _23FloatZero = FloatZero();
                    _24Tetrahedron = Tetrahedron(_23FloatZero);
                    _25MeshVertices = MeshVertices(_24Tetrahedron);
                    _26Constant = -1E+07;
                    _27Vector3 = Vector3(_26Constant, _26Constant, _26Constant);
                    _28Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _27Vector3);
                        _0Add;
                        };
                    _29Map = Map(_25MeshVertices, _28Pass-through: function1);
                    _30SetMeshVertices = SetMeshVertices(_24Tetrahedron, _29Map);
                    _30SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    };
                _32PairItem1 = PairItem1(RayTraceAddGeometry(RayTraceScene(_22False), _31Pass-through: TriMesh));
                _33Pair = Pair(if (_13Equal)
                  {
                    Single _14FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _15Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _16MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _17Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _18Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _19Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _20Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _21SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _14FloatZero = FloatZero();
                    _15Tetrahedron = Tetrahedron(_14FloatZero);
                    _16MeshVertices = MeshVertices(_15Tetrahedron);
                    _17Constant = -1E+07;
                    _18Vector3 = Vector3(_17Constant, _17Constant, _17Constant);
                    _19Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _18Vector3);
                        _0Add;
                        };
                    _20Map = Map(_16MeshVertices, _19Pass-through: function1);
                    _21SetMeshVertices = SetMeshVertices(_15Tetrahedron, _20Map);
                    _21SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    }, _32PairItem1);
                _33Pair;
                }).SetId(state, 0);
            _0CreateStaticCache;
            });
        _4Zero = Zero();
        _5CachedValue = CachedValue(_3IfThen, _4Zero);
        _6PairItem2 = PairItem2(_5CachedValue);
        _7Zero = Zero();
        _8PairItem1 = PairItem1(_5CachedValue);
        _9MeshVertices = MeshVertices(_8PairItem1);
        _10IsValidNode = IsValidNode(obstacle);
        _11IfThen = IfThen(_10IsValidNode, () => 
          {
            Matrix _0ObjectTransformBeforeWSM;// 6:NodeTransformOrIdentity-ext->3:ObjectTransformBeforeWSM 1101567
            _0ObjectTransformBeforeWSM = ObjectTransformBeforeWSM(obstacle);
            _0ObjectTransformBeforeWSM;
            }, () => 
          {
            Matrix _0MatrixIdentity;// 6:NodeTransformOrIdentity-ext->4:MatrixIdentity 1101568
            _0MatrixIdentity = MatrixIdentity();
            _0MatrixIdentity;
            });
        _12InvertMatrix = InvertMatrix(modifierTransform);
        _13Multiply = Multiply(_11IfThen, _12InvertMatrix);
        _14Pass-through: function1 = (Vector3 x0) => 
          {
            Vector3 _0Transform;// 30:TransformMesh->0:Transform 1101543
            _0Transform = Transform(x0, _13Multiply);
            _0Transform;
            };
        _15Map = Map(_9MeshVertices, _14Pass-through: function1);
        _16SetMeshVertices = SetMeshVertices(_8PairItem1, _15Map);
        _17PairItem1 = PairItem1(RayTraceUpdateGeometry(_6PairItem2, _7Zero, _16SetMeshVertices));
        _18Combine = Combine(_1MeshVertices, _2MeshVertices, (Vector3 x0, Vector3 x1) => 
          {
            Single _0Distance;// 3:PointMoveToClampDistance-ext->3:Distance 1101465
            Single _1Abs;// 5:FloatIsSmall-ext->4:Abs 1101463
            Single _2Constant;// 2:VectorLengthEpsilon-ext->0:Constant 1101464
            Boolean _3LessThanOrEqual;// 5:FloatIsSmall-ext->1:LessThanOrEqual 1101462
            Boolean _4Not;// 3:PointMoveToClampDistance-ext->14:Not 1101460
            Vector3 _5Subtract;// 12:RayBetweenPoints-ext->5:Subtract 1101483
            Vector3 _6Normalize;// 12:RayBetweenPoints-ext->3:Normalize 1101482
            Ray _7Ray;// 12:RayBetweenPoints-ext->4:Ray 1101481
            Boolean _8RayTraceHit;// 0:RayTracePointMoveLimited-ext->1:RayTraceHit 1101477
            Single _9IfThen;// 0:RayTracePointMoveLimited-ext->10:IfThen 1101476
            Boolean _10GreaterThan;// 3:PointMoveToClampDistance-ext->9:GreaterThan 1101466
            Boolean _11AndAlso;// 12:AndAlso3-ext->3:AndAlso 1101459
            Single _12FloatZero;// 13:GreaterThanOrEqualToZero->1:FloatZero 1101469
            Boolean _13GreaterThanOrEqual;// 13:GreaterThanOrEqualToZero->2:GreaterThanOrEqual 1101468
            Boolean _14AndAlso;// 12:AndAlso3-ext->4:AndAlso 1101458
            _0Distance = Distance(x0, x1);
            _1Abs = Abs(_0Distance);
            _2Constant = 1E-06;
            _3LessThanOrEqual = LessThanOrEqual(_1Abs, _2Constant);
            _4Not = Not(_3LessThanOrEqual);
            _5Subtract = Subtract(x1, x0);
            _6Normalize = Normalize(_5Subtract);
            _7Ray = Ray(x0, _6Normalize);
            _8RayTraceHit = RayTraceHit(RayTraceFaceIntersection(_17PairItem1, _7Ray));
            _9IfThen = IfThen(_8RayTraceHit, () => 
              {
                Single _0RayTraceDistance;// 0:RayTracePointMoveLimited-ext->8:RayTraceDistance 1101484
                _0RayTraceDistance = RayTraceDistance(RayTraceFaceIntersection(_17PairItem1, _7Ray));
                _0RayTraceDistance;
                }, () => 
              {
                Single _0MaximumFloat;// 0:RayTracePointMoveLimited-ext->11:MaximumFloat 1101485
                _0MaximumFloat = MaximumFloat();
                _0MaximumFloat;
                });
            _10GreaterThan = GreaterThan(_0Distance, _9IfThen);
            _11AndAlso = AndAlso(_4Not, _10GreaterThan);
            _12FloatZero = FloatZero();
            _13GreaterThanOrEqual = GreaterThanOrEqual(_9IfThen, _12FloatZero);
            _14AndAlso = AndAlso(_11AndAlso, _13GreaterThanOrEqual);
            if (_14AndAlso)
              {
                Vector3 _15Subtract;// 3:PointMoveToClampDistance-ext->4:Subtract 1101475
                Vector3 _16Normalize;// 10:SetVectorLength-ext->1:Normalize 1101474
                Vector3 _17MultiplyByScalar;// 10:SetVectorLength-ext->3:MultiplyByScalar 1101473
                Vector3 _18Add;// 3:PointMoveToClampDistance-ext->11:Add 1101470
                _15Subtract = Subtract(x1, x0);
                _16Normalize = Normalize(_15Subtract);
                _17MultiplyByScalar = MultiplyByScalar(_16Normalize, _9IfThen);
                _18Add = Add(x0, _17MultiplyByScalar);
                _18Add;
                }else
              {
                x1;
                };
            });
        _19Zero = Zero();
        _20PerVertexData = PerVertexData(_7SetMeshVertices, _19Zero);
        _21Combine3 = Combine3(_0MeshVertices, _18Combine, _20PerVertexData, (Vector3 x0, Vector3 x1, Single x2) => 
          {
            Vector3 _0Lerp;// 1:LerpVectors-ext->8:Lerp 1101440
            _0Lerp = Lerp(x0, x1, x2);
            _0Lerp;
            });
        _22SetMeshVertices = SetMeshVertices(_7SetMeshVertices, _21Combine3);
        _22SetMeshVertices;
        }, () => 
      {
        IArray[Vector3] _0MeshVertices;// 7:MeshMoveVerticesLimited-ext->3:MeshVertices 1101447
        IArray[Vector3] _1MeshVertices;// 5:MeshMoveVerticesLimitedTowardsNode-ext->4:MeshVertices 1101499
        Cache[Tuple[TriMesh, RayTraceScene]] _2IfThen;// 22:RayTraceSceneCached-ext->14:IfThen 1101509
        Int32 _3Zero;// 7:ExtractCurrentValueFromCache->3:Zero 1101508
        Tuple[TriMesh, RayTraceScene] _4CachedValue;// 7:ExtractCurrentValueFromCache->1:CachedValue 1101507
        RayTraceScene _5PairItem2;// 22:RayTraceSceneCached-ext->28:PairItem2 1101505
        Int32 _6Zero;// 22:RayTraceSceneCached-ext->21:Zero 1101535
        TriMesh _7PairItem1;// 22:RayTraceSceneCached-ext->26:PairItem1 1101544
        IArray[Vector3] _8MeshVertices;// 2:DeformMeshPoints->0:MeshVertices 1101542
        Boolean _9IsValidNode;// 6:NodeTransformOrIdentity-ext->1:IsValidNode 1101566
        Matrix _10IfThen;// 6:NodeTransformOrIdentity-ext->2:IfThen 1101565
        Matrix _11InvertMatrix;// 5:MeshMoveVerticesLimitedTowardsNode-ext->19:InvertMatrix 1101569
        Matrix _12Multiply;// 5:MeshMoveVerticesLimitedTowardsNode-ext->18:Multiply 1101563
        Func[Vector3, Vector3] _13Pass-through: function1;// 0:Pass-through: function1 1101539
        IArray[Vector3] _14Map;// 2:DeformMeshPoints->1:Map 1101541
        TriMesh _15SetMeshVertices;// 2:DeformMeshPoints->4:SetMeshVertices 1101540
        RayTraceScene _16PairItem1;// 22:RayTraceSceneCached-ext->16:PairItem1 1101503
        IArray[Vector3] _17Combine;// 7:MeshMoveVerticesLimited-ext->5:Combine 1101446
        TriMesh _18SetMeshVertices;// 6:MeshSetVertices-ext->8:SetMeshVertices 1101445
        _0MeshVertices = MeshVertices(_7SetMeshVertices);
        _1MeshVertices = MeshVertices(mesh);
        _2IfThen = IfThen(updateCache, () => 
          {
            Cache[Tuple[TriMesh, RayTraceScene]] _0CreateStaticCache;// 22:RayTraceSceneCached-ext->13:CreateStaticCache 1101511
            Cache[Tuple[TriMesh, RayTraceScene]] _1ForceUpdateCache;// 22:RayTraceSceneCached-ext->15:ForceUpdateCache 1101510
            _0CreateStaticCache = CreateStaticCache(() => 
              {
                Boolean _0IsValidNode;// 13:NodeMeshOrDefault-ext->1:IsValidNode 1101548
                TriMesh _10Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101501
                Int32 _11FaceCount;// 22:RayTraceSceneCached-ext->19:FaceCount 1101515
                Int32 _12Zero;// 22:RayTraceSceneCached-ext->22:Zero 1101516
                Boolean _13Equal;// 22:RayTraceSceneCached-ext->20:Equal 1101514
                Boolean _22False;// 11:RayTraceScene-ext->1:False 1101534
                TriMesh _31Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101530
                RayTraceScene _32PairItem1;// 11:RayTraceScene-ext->10:PairItem1 1101531
                Tuple[TriMesh, RayTraceScene] _33Pair;// 22:RayTraceSceneCached-ext->6:Pair 1101512
                _0IsValidNode = IsValidNode(obstacle);
                _10Pass-through: TriMesh = if (_0IsValidNode)
                  {
                    TriMesh _1MeshFromNode;// 13:NodeMeshOrDefault-ext->2:MeshFromNode 1101549
                    _1MeshFromNode = MeshFromNode(obstacle);
                    _1MeshFromNode;
                    }else
                  {
                    Single _2FloatZero;// 5:MeshMoveVerticesLimitedTowardsNode-ext->9:FloatZero 1101559
                    TriMesh _3Tetrahedron;// 5:MeshMoveVerticesLimitedTowardsNode-ext->8:Tetrahedron 1101558
                    IArray[Vector3] _4MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101556
                    Single _5Constant;// 5:MeshMoveVerticesLimitedTowardsNode-ext->0:Constant 1101562
                    Vector3 _6Vector3;// 15:ScalarToVector-ext->1:Vector3 1101561
                    Func[Vector3, Vector3] _7Pass-through: function1;// 0:Pass-through: function1 1101553
                    IArray[Vector3] _8Map;// 0:DeformMeshPoints->1:Map 1101555
                    TriMesh _9SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101554
                    _2FloatZero = FloatZero();
                    _3Tetrahedron = Tetrahedron(_2FloatZero);
                    _4MeshVertices = MeshVertices(_3Tetrahedron);
                    _5Constant = -1E+07;
                    _6Vector3 = Vector3(_5Constant, _5Constant, _5Constant);
                    _7Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 11:OffsetMesh->2:Add 1101557
                        _0Add = Add(x0, _6Vector3);
                        _0Add;
                        };
                    _8Map = Map(_4MeshVertices, _7Pass-through: function1);
                    _9SetMeshVertices = SetMeshVertices(_3Tetrahedron, _8Map);
                    _9SetMeshVertices;
                    };
                _11FaceCount = FaceCount(_10Pass-through: TriMesh);
                _12Zero = Zero();
                _13Equal = Equal(_11FaceCount, _12Zero);
                _22False = False();
                _31Pass-through: TriMesh = if (_13Equal)
                  {
                    Single _23FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _24Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _25MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _26Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _27Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _28Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _29Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _30SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _23FloatZero = FloatZero();
                    _24Tetrahedron = Tetrahedron(_23FloatZero);
                    _25MeshVertices = MeshVertices(_24Tetrahedron);
                    _26Constant = -1E+07;
                    _27Vector3 = Vector3(_26Constant, _26Constant, _26Constant);
                    _28Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _27Vector3);
                        _0Add;
                        };
                    _29Map = Map(_25MeshVertices, _28Pass-through: function1);
                    _30SetMeshVertices = SetMeshVertices(_24Tetrahedron, _29Map);
                    _30SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    };
                _32PairItem1 = PairItem1(RayTraceAddGeometry(RayTraceScene(_22False), _31Pass-through: TriMesh));
                _33Pair = Pair(if (_13Equal)
                  {
                    Single _14FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _15Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _16MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _17Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _18Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _19Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _20Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _21SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _14FloatZero = FloatZero();
                    _15Tetrahedron = Tetrahedron(_14FloatZero);
                    _16MeshVertices = MeshVertices(_15Tetrahedron);
                    _17Constant = -1E+07;
                    _18Vector3 = Vector3(_17Constant, _17Constant, _17Constant);
                    _19Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _18Vector3);
                        _0Add;
                        };
                    _20Map = Map(_16MeshVertices, _19Pass-through: function1);
                    _21SetMeshVertices = SetMeshVertices(_15Tetrahedron, _20Map);
                    _21SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    }, _32PairItem1);
                _33Pair;
                }).SetId(state, 0);
            _1ForceUpdateCache = ForceUpdateCache(_0CreateStaticCache);
            _1ForceUpdateCache;
            }, () => 
          {
            Cache[Tuple[TriMesh, RayTraceScene]] _0CreateStaticCache;// 22:RayTraceSceneCached-ext->13:CreateStaticCache 1101511
            _0CreateStaticCache = CreateStaticCache(() => 
              {
                Boolean _0IsValidNode;// 13:NodeMeshOrDefault-ext->1:IsValidNode 1101548
                TriMesh _10Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101501
                Int32 _11FaceCount;// 22:RayTraceSceneCached-ext->19:FaceCount 1101515
                Int32 _12Zero;// 22:RayTraceSceneCached-ext->22:Zero 1101516
                Boolean _13Equal;// 22:RayTraceSceneCached-ext->20:Equal 1101514
                Boolean _22False;// 11:RayTraceScene-ext->1:False 1101534
                TriMesh _31Pass-through: TriMesh;// 0:Pass-through: TriMesh 1101530
                RayTraceScene _32PairItem1;// 11:RayTraceScene-ext->10:PairItem1 1101531
                Tuple[TriMesh, RayTraceScene] _33Pair;// 22:RayTraceSceneCached-ext->6:Pair 1101512
                _0IsValidNode = IsValidNode(obstacle);
                _10Pass-through: TriMesh = if (_0IsValidNode)
                  {
                    TriMesh _1MeshFromNode;// 13:NodeMeshOrDefault-ext->2:MeshFromNode 1101549
                    _1MeshFromNode = MeshFromNode(obstacle);
                    _1MeshFromNode;
                    }else
                  {
                    Single _2FloatZero;// 5:MeshMoveVerticesLimitedTowardsNode-ext->9:FloatZero 1101559
                    TriMesh _3Tetrahedron;// 5:MeshMoveVerticesLimitedTowardsNode-ext->8:Tetrahedron 1101558
                    IArray[Vector3] _4MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101556
                    Single _5Constant;// 5:MeshMoveVerticesLimitedTowardsNode-ext->0:Constant 1101562
                    Vector3 _6Vector3;// 15:ScalarToVector-ext->1:Vector3 1101561
                    Func[Vector3, Vector3] _7Pass-through: function1;// 0:Pass-through: function1 1101553
                    IArray[Vector3] _8Map;// 0:DeformMeshPoints->1:Map 1101555
                    TriMesh _9SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101554
                    _2FloatZero = FloatZero();
                    _3Tetrahedron = Tetrahedron(_2FloatZero);
                    _4MeshVertices = MeshVertices(_3Tetrahedron);
                    _5Constant = -1E+07;
                    _6Vector3 = Vector3(_5Constant, _5Constant, _5Constant);
                    _7Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 11:OffsetMesh->2:Add 1101557
                        _0Add = Add(x0, _6Vector3);
                        _0Add;
                        };
                    _8Map = Map(_4MeshVertices, _7Pass-through: function1);
                    _9SetMeshVertices = SetMeshVertices(_3Tetrahedron, _8Map);
                    _9SetMeshVertices;
                    };
                _11FaceCount = FaceCount(_10Pass-through: TriMesh);
                _12Zero = Zero();
                _13Equal = Equal(_11FaceCount, _12Zero);
                _22False = False();
                _31Pass-through: TriMesh = if (_13Equal)
                  {
                    Single _23FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _24Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _25MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _26Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _27Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _28Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _29Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _30SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _23FloatZero = FloatZero();
                    _24Tetrahedron = Tetrahedron(_23FloatZero);
                    _25MeshVertices = MeshVertices(_24Tetrahedron);
                    _26Constant = -1E+07;
                    _27Vector3 = Vector3(_26Constant, _26Constant, _26Constant);
                    _28Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _27Vector3);
                        _0Add;
                        };
                    _29Map = Map(_25MeshVertices, _28Pass-through: function1);
                    _30SetMeshVertices = SetMeshVertices(_24Tetrahedron, _29Map);
                    _30SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    };
                _32PairItem1 = PairItem1(RayTraceAddGeometry(RayTraceScene(_22False), _31Pass-through: TriMesh));
                _33Pair = Pair(if (_13Equal)
                  {
                    Single _14FloatZero;// 22:RayTraceSceneCached-ext->10:FloatZero 1101526
                    TriMesh _15Tetrahedron;// 22:RayTraceSceneCached-ext->9:Tetrahedron 1101525
                    IArray[Vector3] _16MeshVertices;// 0:DeformMeshPoints->0:MeshVertices 1101523
                    Single _17Constant;// 22:RayTraceSceneCached-ext->0:Constant 1101529
                    Vector3 _18Vector3;// 12:ScalarToVector-ext->1:Vector3 1101528
                    Func[Vector3, Vector3] _19Pass-through: function1;// 0:Pass-through: function1 1101520
                    IArray[Vector3] _20Map;// 0:DeformMeshPoints->1:Map 1101522
                    TriMesh _21SetMeshVertices;// 0:DeformMeshPoints->4:SetMeshVertices 1101521
                    _14FloatZero = FloatZero();
                    _15Tetrahedron = Tetrahedron(_14FloatZero);
                    _16MeshVertices = MeshVertices(_15Tetrahedron);
                    _17Constant = -1E+07;
                    _18Vector3 = Vector3(_17Constant, _17Constant, _17Constant);
                    _19Pass-through: function1 = (Vector3 x0) => 
                      {
                        Vector3 _0Add;// 4:OffsetMesh->2:Add 1101524
                        _0Add = Add(x0, _18Vector3);
                        _0Add;
                        };
                    _20Map = Map(_16MeshVertices, _19Pass-through: function1);
                    _21SetMeshVertices = SetMeshVertices(_15Tetrahedron, _20Map);
                    _21SetMeshVertices;
                    }else
                  {
                    _10Pass-through: TriMesh;
                    }, _32PairItem1);
                _33Pair;
                }).SetId(state, 0);
            _0CreateStaticCache;
            });
        _3Zero = Zero();
        _4CachedValue = CachedValue(_2IfThen, _3Zero);
        _5PairItem2 = PairItem2(_4CachedValue);
        _6Zero = Zero();
        _7PairItem1 = PairItem1(_4CachedValue);
        _8MeshVertices = MeshVertices(_7PairItem1);
        _9IsValidNode = IsValidNode(obstacle);
        _10IfThen = IfThen(_9IsValidNode, () => 
          {
            Matrix _0ObjectTransformBeforeWSM;// 6:NodeTransformOrIdentity-ext->3:ObjectTransformBeforeWSM 1101567
            _0ObjectTransformBeforeWSM = ObjectTransformBeforeWSM(obstacle);
            _0ObjectTransformBeforeWSM;
            }, () => 
          {
            Matrix _0MatrixIdentity;// 6:NodeTransformOrIdentity-ext->4:MatrixIdentity 1101568
            _0MatrixIdentity = MatrixIdentity();
            _0MatrixIdentity;
            });
        _11InvertMatrix = InvertMatrix(modifierTransform);
        _12Multiply = Multiply(_10IfThen, _11InvertMatrix);
        _13Pass-through: function1 = (Vector3 x0) => 
          {
            Vector3 _0Transform;// 30:TransformMesh->0:Transform 1101543
            _0Transform = Transform(x0, _12Multiply);
            _0Transform;
            };
        _14Map = Map(_8MeshVertices, _13Pass-through: function1);
        _15SetMeshVertices = SetMeshVertices(_7PairItem1, _14Map);
        _16PairItem1 = PairItem1(RayTraceUpdateGeometry(_5PairItem2, _6Zero, _15SetMeshVertices));
        _17Combine = Combine(_0MeshVertices, _1MeshVertices, (Vector3 x0, Vector3 x1) => 
          {
            Single _0Distance;// 3:PointMoveToClampDistance-ext->3:Distance 1101465
            Single _1Abs;// 5:FloatIsSmall-ext->4:Abs 1101463
            Single _2Constant;// 2:VectorLengthEpsilon-ext->0:Constant 1101464
            Boolean _3LessThanOrEqual;// 5:FloatIsSmall-ext->1:LessThanOrEqual 1101462
            Boolean _4Not;// 3:PointMoveToClampDistance-ext->14:Not 1101460
            Vector3 _5Subtract;// 12:RayBetweenPoints-ext->5:Subtract 1101483
            Vector3 _6Normalize;// 12:RayBetweenPoints-ext->3:Normalize 1101482
            Ray _7Ray;// 12:RayBetweenPoints-ext->4:Ray 1101481
            Boolean _8RayTraceHit;// 0:RayTracePointMoveLimited-ext->1:RayTraceHit 1101477
            Single _9IfThen;// 0:RayTracePointMoveLimited-ext->10:IfThen 1101476
            Boolean _10GreaterThan;// 3:PointMoveToClampDistance-ext->9:GreaterThan 1101466
            Boolean _11AndAlso;// 12:AndAlso3-ext->3:AndAlso 1101459
            Single _12FloatZero;// 13:GreaterThanOrEqualToZero->1:FloatZero 1101469
            Boolean _13GreaterThanOrEqual;// 13:GreaterThanOrEqualToZero->2:GreaterThanOrEqual 1101468
            Boolean _14AndAlso;// 12:AndAlso3-ext->4:AndAlso 1101458
            _0Distance = Distance(x0, x1);
            _1Abs = Abs(_0Distance);
            _2Constant = 1E-06;
            _3LessThanOrEqual = LessThanOrEqual(_1Abs, _2Constant);
            _4Not = Not(_3LessThanOrEqual);
            _5Subtract = Subtract(x1, x0);
            _6Normalize = Normalize(_5Subtract);
            _7Ray = Ray(x0, _6Normalize);
            _8RayTraceHit = RayTraceHit(RayTraceFaceIntersection(_16PairItem1, _7Ray));
            _9IfThen = IfThen(_8RayTraceHit, () => 
              {
                Single _0RayTraceDistance;// 0:RayTracePointMoveLimited-ext->8:RayTraceDistance 1101484
                _0RayTraceDistance = RayTraceDistance(RayTraceFaceIntersection(_16PairItem1, _7Ray));
                _0RayTraceDistance;
                }, () => 
              {
                Single _0MaximumFloat;// 0:RayTracePointMoveLimited-ext->11:MaximumFloat 1101485
                _0MaximumFloat = MaximumFloat();
                _0MaximumFloat;
                });
            _10GreaterThan = GreaterThan(_0Distance, _9IfThen);
            _11AndAlso = AndAlso(_4Not, _10GreaterThan);
            _12FloatZero = FloatZero();
            _13GreaterThanOrEqual = GreaterThanOrEqual(_9IfThen, _12FloatZero);
            _14AndAlso = AndAlso(_11AndAlso, _13GreaterThanOrEqual);
            if (_14AndAlso)
              {
                Vector3 _15Subtract;// 3:PointMoveToClampDistance-ext->4:Subtract 1101475
                Vector3 _16Normalize;// 10:SetVectorLength-ext->1:Normalize 1101474
                Vector3 _17MultiplyByScalar;// 10:SetVectorLength-ext->3:MultiplyByScalar 1101473
                Vector3 _18Add;// 3:PointMoveToClampDistance-ext->11:Add 1101470
                _15Subtract = Subtract(x1, x0);
                _16Normalize = Normalize(_15Subtract);
                _17MultiplyByScalar = MultiplyByScalar(_16Normalize, _9IfThen);
                _18Add = Add(x0, _17MultiplyByScalar);
                _18Add;
                }else
              {
                x1;
                };
            });
        _18SetMeshVertices = SetMeshVertices(_7SetMeshVertices, _17Combine);
        _18SetMeshVertices;
        });
    _13IfThen;
    }